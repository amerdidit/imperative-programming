# Programming Paradigms


## **Imperative Programming:**
* lat. imperare = to instruct
* The idea is to give the computer step by step instructions to solve a problem.
* The paradigm is a result of the *von-Neumann-Architecture*
* In order to deviate from the step by step instructions in a dynamic manner, Goto (jump instructions) are used.
* The instructions process *data* that is stored in memory.
* Data is usually saved to a *variable*
* a **variable** is a *logical* memory-space. Logical here means that the programer doesn't have to worry about the technical aspects of it.
* Two forms of the impertaive programming paradigm  are:
	* **Procedural imperative programming**
		* The data and the program's instructions are handled seperately.
		* A *procedure* sums together a subset of instructions.
		* These procedures can then be *called*
		* This increases the compactness of the programm, and provides as easier overview.
		* examples:
			* C
			* COBOL
			* FORTRAN
			* Pascal
			* PL/1
	* **object-oriented imperative programming**
		* Data and the operations that can be executed on that data are summed up as *objects*
		* objects usually represent real-life entities. (Bank accounts, customers, ...etc)
		* The focus is on the Data.
		* The structure is on summing together Objects, and *modularity*
		* examples:
			* C++
			* C#
			* Java
			* Smalltalk

## **Declarative Programming**
* The desired result is declared, and a program finds the solution.
* example: MySQL

## **Logical Programming**
* uses mathematical logic to present and solve problems
* example: PROLOG

## **Functional Programming**
* uses mathematical functions to formulate programs.
* functions can be made up of more functions.
* examples:
	* List (1969)
	* Scheme (1987)

